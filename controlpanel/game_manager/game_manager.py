import osimport sysimport pygame as pgimport importlibimport inspectimport controlpanelfrom .games import BaseGame, FallbackGamefrom controlpanel.shaders import Shadersfrom .dev_overlay import DeveloperOverlay, console_commandfrom .utils import get_output_size, get_display_flagsfrom collections import dequefrom typing import TypeVarimport platformfrom pathlib import Pathif platform.system() == "Windows":  # Circumvent windows display setting "scale" factor resulting in blurry images    import ctypes    ctypes.windll.user32.SetProcessDPIAware()T = TypeVar("T", bound="BaseGame")class GameManager:    def __init__(            self,            resolution: tuple[int, int],            dev_args: list[str] | None = None, *,            is_fullscreen: bool,            use_shaders: bool,            stretch_to_fit: bool,            enable_cheats: bool,    ):        pg.init()        self._games: dict[str:BaseGame] = dict()        self._base_cwd = os.getcwd()        self._current_game: BaseGame | None = None        self._resolution = resolution        self._screen = pg.display.set_mode(get_output_size(resolution, is_fullscreen, use_shaders, stretch_to_fit),                                           flags=get_display_flags(is_fullscreen, use_shaders))        self._render_screen = pg.Surface(resolution)        self._joysticks: dict[int: pg.joystick.JoystickType] = dict()        self.use_shaders = use_shaders        self._dev_overlay = DeveloperOverlay({"game_manager": self, "cp": controlpanel}, self._render_screen,                                             enable_cheats=enable_cheats)        self._running = True        self._show_fps = True        self._frame_time_buffer_time = 3.0        self._frame_times: deque[int] = deque()        self._dev_args: list[str] = self.parse_dev_args(dev_args) if dev_args is not None else []    @staticmethod    def parse_dev_args(input_list: list[str]) -> list[str]:        output = []        current = []        for item in input_list:            if item.startswith('-'):                if current:                    output.append(" ".join(current))                current = [item.lstrip('-').replace("-", "_")]            else:                current.append(item)        if current:            output.append(" ".join(current))        return output    def add_game(self, game: T, make_current: bool = False) -> T:        if self._games.get(game.name) is not None:            raise ValueError(f"Game with name {game.name} already exists!")        self._games[game.name] = game        setattr(self._dev_overlay.namespace, game.name.lower().replace(" ", "_"), game)  # todo: private attr        game._joysticks = self._joysticks        if make_current:            self.change_game(game.name)        return game    def get_game(self, name: str | None = None) -> BaseGame | None:        if name is None:            return self._current_game        return self._games.get(name)    # def change_game_autocomplete(self) -> tuple[int, list["Autocomplete.Option"]]:    #     return 0, list(Autocomplete.Option(name, str(game.__doc__ or "")) for name, game in self._games)    @console_command    def list_games(self):        print("Currently loaded games:")        for game_name in self._games.keys():            print(f"- {game_name}")    @console_command(is_cheat_protected=True)    def change_game(self, name: str) -> None:        """Changes the current game. Game needs to have been loaded first."""        game: BaseGame = self._games.get(name)        if not game:            print(f"No game named {name} is currently loaded.")            return        if game.working_directory_override:            os.chdir(game.working_directory_override)        else:            os.chdir(self._base_cwd)        self._current_game = game    def draw_fps_counter(self, surface: pg.Surface):        if not self._frame_times:            return        avg_fps = 1000 / (sum(self._frame_times) / len(self._frame_times))        if avg_fps < 0.8 * self._current_game.tickrate:            fps_color = (255, 0, 0)        elif 0.8 * self._current_game.tickrate <= avg_fps < 0.95 * self._current_game.tickrate:            fps_color = (255, 255, 0)        else:            fps_color = (0, 255, 0)        max_frame_time = max(self._frame_times)        if max_frame_time > int(1.25 * 1000/max(self._current_game.tickrate, 1.0)):            frame_time_color = (255, 0, 0)        elif int(1.25 * 1000/max(self._current_game.tickrate, 1.0)) >= max_frame_time >= 1/0.95 * 1000/max(self._current_game.tickrate, 1.0):            frame_time_color = (255, 255, 0)        else:            frame_time_color = (0, 255, 0)        surface.blit(self._dev_overlay.font.render(f"FPS: {int(avg_fps)}", True, fps_color), (2, 2))        surface.blit(self._dev_overlay.font.render(f"MAX: {max_frame_time}ms", True, frame_time_color), (2, 22))    @console_command("showfps", hint=lambda self: int(self._show_fps))    def set_fps_counter(self, enable: int):        """Show or hide the FPS counter"""        self._show_fps = bool(enable)    @console_command("screenshot")    def take_screenshot(self, filename: str = None):        """Takes a screenshot and saves it as PNG in the cwd."""        if not filename:            from datetime import datetime            timestamp = datetime.now().strftime("%d%m%Y-%H%M%S")            filename = f"{self._current_game.name}_{timestamp}.png"        elif not any(filename.lower().endswith(filetype) for filetype in (".png", ".jpg", ".tga", ".bmp")):            filename += ".png"        pg.image.save(self._current_game.screen, filename)        print(f"Exported screenshot to {filename}")    @console_command("quit", "exit", is_cheat_protected=True)    def quit(self):        """Quit the game"""        self._running = False    @console_command(is_cheat_protected=True)    def load_game(self, module_name: str, module_directory: str = ".", *args) -> None:        """Dynamically load a game from a different directory. Example: 'load_game game_module.main ../GameDirectory'"""        from controlpanel.game_manager import BaseGame  # TODO: remove lazy import?        # If an extra_path is provided, join it with CWD and add to sys.path        if module_directory:            # Make sure to join the provided extra_path with the current working directory            module_directory = Path(module_directory).resolve()  # Resolves the path to an absolute path            sys.path.append(str(module_directory))        try:            # Try importing the game module            print(f"Attempting to load {module_name} from {module_directory}...")            game_module = importlib.import_module(module_name)        except ModuleNotFoundError as e:            print(f'Failed to load module "{module_name}" due to missing module: {e}')            return        # Scan the module for classes that inherit from BaseGame        games = []        for name, obj in inspect.getmembers(game_module, inspect.isclass):            # Make sure the class is defined in the module (not just imported into it)            if issubclass(obj, BaseGame) and obj is not BaseGame and obj.__module__ == game_module.__name__:                games.append(obj)        if not games:            print(f'Cannot load game: Successfully imported module {module_name},'                  f'but failed to find any instance of BaseGame inside.')            return        # Instantiate and use them        for cls in games:            os.chdir(module_directory)            instance = cls(*args)            instance._working_directory_override = module_directory            print(f"Successfully loaded {cls.__name__}")            self.add_game(instance, True)    @console_command(is_cheat_protected=True)    def send_artdmx(self, device_name_or_universe: str | int, *values: int) -> None:        """Sends any number of integer values (0-255) to the universe of the given device"""        from controlpanel.scripts import ControlAPI        if ControlAPI.artnet:            data = bytes(values)            if type(device_name_or_universe) is str:                ControlAPI.send_dmx(device_name_or_universe, data)            elif type(device_name_or_universe) is int and 0 <= device_name_or_universe <= 65535:                ControlAPI.artnet.send_dmx(device_name_or_universe, 0, bytearray(data))        else:            print("Cannot send ArtDMX because artnet is not initialized")    @console_command(is_cheat_protected=True)    def send_artcmd(self, cmd: str):        """Sends the given ASCII string as an ArtCommand packet via Artnet"""        from controlpanel.scripts import ControlAPI        if ControlAPI.artnet:            ControlAPI.artnet.send_command(cmd.encode("ascii"))        else:            print("Cannot send ArtCommand because artnet is not initialized")    @console_command(is_cheat_protected=True)    def send_arttrigger(self, key: int, subkey: int, data: str):        """Sends the given ASCII string as an ArtCommand packet via Artnet"""        from controlpanel.scripts import ControlAPI        if ControlAPI.artnet:            ControlAPI.artnet.send_trigger(key, subkey, bytearray(data.encode("ASCII")))        else:            print("Cannot send ArtTrigger because artnet is not initialized")    @console_command(is_cheat_protected=True)    def set_dmx_attr(self, device_name: str, attribute: str, value):        """Sets any attribute of any DMX device to any value"""        from controlpanel.scripts import ControlAPI        setattr(ControlAPI.dmx.devices.get(device_name), attribute, value)    def run(self):        if self._current_game is None and self._games:            self._current_game = list(self._games.values())[0]        for arg in self._dev_args:            self._dev_overlay.dev_console.handle_command(arg, suppress_logging=True, ignore_cheat_protection=True)        if self.use_shaders:            RENDER_SIZE = self._resolution            QUARTER_RENDER_SIZE = (self._resolution[0]//2, self._resolution[1]//2)            crt_shaders = Shaders(texture_sizes=[RENDER_SIZE, QUARTER_RENDER_SIZE, QUARTER_RENDER_SIZE],                                  shader_operations=[(1, "Downscale", {"_MainTex": 0}),                                                     (1, "Threshold", {"_MainTex": 1}),                                                     (1, "Blur_H", {"_MainTex": 1}),                                                     (1, "Blur_V", {"_MainTex": 1}),                                                     (2, "Ghost", {"_MainTex": 1, "_SecondaryTex": 2}),                                                     (0, "Add", {"_MainTex": 0, "_SecondaryTex": 2}),                                                     (0, "CRT", {"_MainTex": 0}),                                                     (-1, "To_BGRA", {"_MainTex": 0}),                                                     ])            # no_shaders = Shaders(texture_sizes=[RENDER_SIZE], shader_operations=[(-1, "To_BGRA", {"_MainTex": 0}),])        clock = pg.time.Clock()        if self._current_game is None:            self.add_game(FallbackGame(), make_current=True)        while self._running:            events = pg.event.get()            for event in events:                if event.type == pg.QUIT:                    pg.quit()                elif event.type == pg.JOYDEVICEADDED:                    joy = pg.joystick.Joystick(event.device_index)                    self._joysticks[joy.get_instance_id()] = joy                elif event.type == pg.KEYDOWN and event.scancode == 53:                    self._dev_overlay.open = not self._dev_overlay.open                elif event.type == pg.KEYDOWN and event.key == pg.K_F12:                    self.take_screenshot()            if self._dev_overlay.open:                self._dev_overlay.handle_events(events)            else:                if any(getattr(child, "pinned", False) for child in self._dev_overlay.children):                    self._dev_overlay.handle_events(events)                self._current_game.handle_events(events)            self._current_game.update()            self._current_game.render()            if self.use_shaders:                self._render_screen.blit(self._current_game.screen, (0, 0))            else:                if self._current_game.screen.get_size() != self._render_screen.get_size():                    pg.transform.scale(self._current_game.screen, self._render_screen.get_size(), self._render_screen)                else:                    self._render_screen.blit(self._current_game.screen, (0, 0))            self._dev_overlay.render()            if self._show_fps:                if self._frame_times.maxlen != max(1, int(self._current_game.tickrate * self._frame_time_buffer_time)):                    self._frame_times = deque(maxlen=max(1, int(self._current_game.tickrate * self._frame_time_buffer_time)))                self.draw_fps_counter(self._render_screen)            if self.use_shaders:                crt_shaders.apply([self._render_screen, ])            else:                if self._render_screen.get_size() != self._screen.get_size():                    pg.transform.scale(self._render_screen, self._screen.get_size(), self._screen)                else:                    self._screen.blit(self._render_screen, (0, 0))            pg.display.flip()            dt_ms = clock.tick(self._current_game.tickrate)            self._frame_times.append(dt_ms)            self._current_game._dt = dt_ms / 1000 * self._current_game.timescale        pg.quit()