import osimport pygame as pgfrom .games import BaseGame, FallbackGamefrom controlpanel.shaders import Shadersfrom .dev_overlay import DeveloperOverlay, console_command, Logger, OutputRedirectorfrom .utils import get_output_size, get_display_flagsfrom collections import dequeimport sysfrom typing import TypeVarimport platformif platform.system() == "Windows":  # Circumvent windows display setting "scale" factor resulting in blurry images    import ctypes    ctypes.windll.user32.SetProcessDPIAware()T = TypeVar("T", bound="BaseGame")class GameManager:    def __init__(            self,            resolution: tuple[int, int],            dev_args: list[str] | None = None, *,            is_fullscreen: bool,            use_shaders: bool,            stretch_to_fit: bool,            enable_cheats: bool,    ):        pg.init()        self._games: dict[str:BaseGame] = dict()        self._base_cwd = os.getcwd()        self._current_game: BaseGame | None = None        self._resolution = resolution        self._screen = pg.display.set_mode(get_output_size(resolution, is_fullscreen, use_shaders, stretch_to_fit),                                           flags=get_display_flags(is_fullscreen, use_shaders))        self._render_screen = pg.Surface(resolution)        self._joysticks: dict[int: pg.joystick.JoystickType] = dict()        self.use_shaders = use_shaders        self.cheats_enabled = enable_cheats        self._dev_overlay = DeveloperOverlay(self, self._render_screen)        self._logger = Logger(self._screen)        self._running = True        self._show_fps = True        self._frame_time_buffer_time = 3.0        self._frame_times: deque[int] = deque()        self._developer_mode = False        self._dev_args: list[str] = self.parse_dev_args(dev_args) if dev_args is not None else []        sys.stdout = OutputRedirector(self._dev_overlay.dev_console.log.print, self._logger.print)    @staticmethod    def parse_dev_args(input_list: list[str]) -> list[str]:        output = []        current = []        for item in input_list:            if item.startswith('-'):                if current:                    output.append(" ".join(current))                current = [item.lstrip('-').replace("-", "_")]            else:                current.append(item)        if current:            output.append(" ".join(current))        return output    def add_game(self, game: T, make_current: bool = False) -> T:        if self._games.get(game.name) is not None:            raise ValueError(f"Game with name {game.name} already exists!")        self._games[game.name] = game        setattr(self._dev_overlay.dev_console._namespace, game.name.lower().replace(" ", "_"), game)  # todo: private attr        game._joysticks = self._joysticks        if make_current:            self.change_game(game.name)        return game    def get_game(self, name: str | None = None) -> BaseGame | None:        if name is None:            return self._current_game        return self._games.get(name)    # def change_game_autocomplete(self) -> tuple[int, list["Autocomplete.Option"]]:    #     return 0, list(Autocomplete.Option(name, str(game.__doc__ or "")) for name, game in self._games)    @console_command(is_cheat_protected=True)    def change_game(self, name: str) -> None:        """Changes the current game. Game needs to have been loaded first."""        game: BaseGame = self._games.get(name)        if not game:            print(f"No game named {name} is currently loaded.")            return        if game.working_directory_override:            os.chdir(game.working_directory_override)        else:            os.chdir(self._base_cwd)        self._current_game = game    def draw_fps_counter(self, surface: pg.Surface):        if not self._frame_times:            return        avg_fps = 1000 / (sum(self._frame_times) / len(self._frame_times))        if avg_fps < 0.8 * self._current_game.tickrate:            fps_color = (255, 0, 0)        elif 0.8 * self._current_game.tickrate <= avg_fps < 0.95 * self._current_game.tickrate:            fps_color = (255, 255, 0)        else:            fps_color = (0, 255, 0)        max_frame_time = max(self._frame_times)        if max_frame_time > int(1.25 * 1000/max(self._current_game.tickrate, 1.0)):            frame_time_color = (255, 0, 0)        elif int(1.25 * 1000/max(self._current_game.tickrate, 1.0)) >= max_frame_time >= 1/0.95 * 1000/max(self._current_game.tickrate, 1.0):            frame_time_color = (255, 255, 0)        else:            frame_time_color = (0, 255, 0)        surface.blit(self._dev_overlay.font.render(f"FPS: {int(avg_fps)}", True, fps_color), (2, 2))        surface.blit(self._dev_overlay.font.render(f"MAX: {max_frame_time}ms", True, frame_time_color), (2, 22))    @console_command("developer", hint=lambda self: int(self._developer_mode))    def set_developer_mode(self, enable: int):        """If set, print stdout to the screen"""        self._developer_mode = bool(enable)    @console_command("showfps", hint=lambda self: int(self._show_fps))    def set_fps_counter(self, enable: int):        """Show or hide the FPS counter"""        self._show_fps = bool(enable)    @console_command("toggleconsole")    def toggle_dev_console(self):        """Toggles the developer console"""        self._dev_overlay.open = not self._dev_overlay.open    @console_command("screenshot")    def take_screenshot(self, filename: str = None):        """Takes a screenshot and saves it as PNG in the cwd."""        if not filename:            from datetime import datetime            timestamp = datetime.now().strftime("%d%m%Y-%H%M%S")            filename = f"{self._current_game.name}_{timestamp}.png"        elif not any(filename.lower().endswith(filetype) for filetype in (".png", ".jpg", ".tga", ".bmp")):            filename += ".png"        pg.image.save(self._current_game.screen, filename)        print(f"Exported screenshot to {filename}")    @console_command("quit", "exit", is_cheat_protected=True)    def quit(self):        """Quit the game"""        self._running = False    def run(self):        if self._current_game is None and self._games:            self._current_game = list(self._games.values())[0]        for arg in self._dev_args:            self._dev_overlay.dev_console.handle_command(arg, suppress_logging=True, ignore_cheat_protection=True)        if self.use_shaders:            RENDER_SIZE = self._resolution            QUARTER_RENDER_SIZE = (self._resolution[0]//2, self._resolution[1]//2)            crt_shaders = Shaders(texture_sizes=[RENDER_SIZE, QUARTER_RENDER_SIZE, QUARTER_RENDER_SIZE],                                  shader_operations=[(1, "Downscale", {"_MainTex": 0}),                                                     (1, "Threshold", {"_MainTex": 1}),                                                     (1, "Blur_H", {"_MainTex": 1}),                                                     (1, "Blur_V", {"_MainTex": 1}),                                                     (2, "Ghost", {"_MainTex": 1, "_SecondaryTex": 2}),                                                     (0, "Add", {"_MainTex": 0, "_SecondaryTex": 2}),                                                     (0, "CRT", {"_MainTex": 0}),                                                     (-1, "To_BGRA", {"_MainTex": 0}),                                                     ])            # no_shaders = Shaders(texture_sizes=[RENDER_SIZE], shader_operations=[(-1, "To_BGRA", {"_MainTex": 0}),])        clock = pg.time.Clock()        if self._current_game is None:            self.add_game(FallbackGame(), make_current=True)        while self._running:            events = pg.event.get()            for event in events:                if event.type == pg.QUIT:                    pg.quit()                elif event.type == pg.JOYDEVICEADDED:                    joy = pg.joystick.Joystick(event.device_index)                    self._joysticks[joy.get_instance_id()] = joy                elif event.type == pg.KEYDOWN and event.scancode == 53:                    self._dev_overlay.open = not self._dev_overlay.open                elif event.type == pg.KEYDOWN and event.key == pg.K_F12:                    self.take_screenshot()            if self._dev_overlay.open:                self._dev_overlay.handle_events(events)            else:                if any(getattr(child, "pinned", False) for child in self._dev_overlay.children):                    self._dev_overlay.handle_events(events)                self._current_game.handle_events(events)            self._current_game.update()            self._current_game.render()            if self.use_shaders:                self._render_screen.blit(self._current_game.screen, (0, 0))            else:                if self._current_game.screen.get_size() != self._render_screen.get_size():                    pg.transform.scale(self._current_game.screen, self._render_screen.get_size(), self._render_screen)                else:                    self._render_screen.blit(self._current_game.screen, (0, 0))            self._dev_overlay.render()            if self._developer_mode:                self._logger.render(self._render_screen)            if self._show_fps:                if self._frame_times.maxlen != max(1, int(self._current_game.tickrate * self._frame_time_buffer_time)):                    self._frame_times = deque(maxlen=max(1, int(self._current_game.tickrate * self._frame_time_buffer_time)))                self.draw_fps_counter(self._render_screen)            if self.use_shaders:                crt_shaders.apply([self._render_screen, ])            else:                if self._render_screen.get_size() != self._screen.get_size():                    pg.transform.scale(self._render_screen, self._screen.get_size(), self._screen)                else:                    self._screen.blit(self._render_screen, (0, 0))            pg.display.flip()            dt_ms = clock.tick(self._current_game.tickrate)            self._frame_times.append(dt_ms)            self._current_game._dt = dt_ms / 1000 * self._current_game.timescale        pg.quit()